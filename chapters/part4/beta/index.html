
% rebase('templates/chapter.html', title="Beta Distribution")

<style>
        .axis path,
        .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }
        .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 1.5px;
        }
        .area {
            fill: lightsteelblue;
            stroke-width: 0;
        }
    </style>
 
<center><h1>Beta Distribution</h1></center>
<hr/>

<p>
                    The Beta distribution is the distribution most often used as the distribution of probabilities. In this section we are going to have a very meta discussion about how we represent probabilities. Until now probabilities have just been numbers in the range 0 to 1. However, if we have uncertainty about our probability, it would make sense to represent our probabilities as random variables (and thus articulate the relative likelihood of our belief).
                </p>

                <h2>Beta Demo</h2>

                <p>Let $a$ represent the number of successes + 1. Let $b$ represent the number of fails + 1. $X \sim \Beta(a, b)$ represents your belief as a <i>distribution</i> of the probability of a success.

                <h3> Parameters</h3>
                <form class="form-inline">
                  <div class="form-group">
                    <label for="inputEmail3" class="col-sm-4 control-label">a: &nbsp;&nbsp;</label>
                    <div class="col-sm-4">
                      <input type="number" class="form-control" id="inputAlpha" value="8">
                    </div>
                  </div>
                 </form>
                  <form class="form-inline">
                  <div class="form-group">
                    <label for="inputPassword3" class="col-sm-4 control-label">b: </label>
                    <div class="col-sm-4">
                      <input type="number" class="form-control" id="inputBeta" value="2">
                    </div>
                  </div>
                  </form>
                  
                 <p>
                  <button class="btn btn-primary" onclick="calculate()" style="font-family:monospace">beta pdf</button>
                </p>
                
                

                <div id="hidden" style="display:none">
                            <h3>Beta PDF</h3>
                            <div style="width:500px; height:370px;" id="pdfDiv"></div>
                </div>
                

        
        
        
        
                




<h2>Estimating Probabilities</h2>
<p>Imagine we have a coin and we would like to know its probability of coming up heads ($p$). We flip the coin $(n+m)$ times and it comes up head $n$ times. One way to calculate the probability is to assume that it is exactly $p = \frac{n}{n+m}$. That number, however, is a coarse estimate, especially if $n+m$ is small. Intuitively it doesn't capture our uncertainty about the value of $p$. Just like with other random variables, it often makes sense to hold a distributed belief about the value of $p$. 

<p>To formalize the idea that we want a distribution for $p$ we are going to use a random variable $X$ to represent the probability of the coin coming up heads. Before flipping the coin, we could say that our belief about the coin's success probability is uniform: $X \sim \Uni(0, 1)$.

<p>If we let $N$ be the number of heads that came up, given that the coin flips are independent, $(N|X) \sim Bin(n + m, x)$. We want to calculate the probability density function for $X|N$. We can start by applying Bayes Theorem:
\begin{align*}
    f(X = x|N =n) &=  \frac{P(N=n|X=x)f(X=x)}{P(N=n)} && \text{Bayes Theorem}\\
&= \frac{ { {n+m} \choose n} x^n(1-x)^m}{P(N=n)} && \text{Binomial PMF, Uniform PDF}\\
&= \frac{ { {n+m} \choose n}}{P(N=n)}x^n(1-x)^m && \text{Moving terms around}\\
&= \frac{1}{c} \cdot x^n(1-x)^m && \text{where } c = \int_0^1 x^n(1-x)^mdx
\end{align*}

<h2>Beta Distribution</h2>

<p>The equation that we arrived at when using a Bayesian approach to estimating our probability defines a probability density function and thus a random variable. The random variable is called a Beta distribution, and it is defined as follows:

<p>The Probability Density Function (PDF) for a Beta $X \sim \Beta(a,b)$ is:
\begin{align*}
    f(X=x) = 
    \begin{cases} 
    \frac{1}{B(a,b)}x^{a-1}(1-x)^{b-1} &\mbox{if } 0 < x < 1 \\ 
    0 & \mbox{otherwise} 
    \end{cases}  
   &&\mbox{where } B(a,b) = \int_0^1x^{a-1}(1-x)^{b-1}dx
\end{align*}
A Beta distribution has $E[X] = \frac{a}{a + b}$ and $Var(X) = \frac{ab}{(a+b)^2(a+b+1)}$. All modern programming languages have a package for calculating Beta CDFs. You will not be expected to compute the CDF by hand in CS109.

<p>To model our estimate of the probability of a coin coming up heads as a beta set $a = n + 1$ and $b = m + 1$. Beta is used as a random variable to represent a belief distribution of probabilities in contexts beyond estimating coin flips. It has many desirable properties: it has a support range that is exactly $(0, 1)$, matching the values that probabilities can take on and it has the expressive capacity to capture many different forms of belief distributions. 

<p>Let's imagine that we had observed $n=4$ heads and $m=2$ tails. The probability density function for $X \sim \text{Beta}(5, 3)$ is:
<p><center><img class="mainFigure" src="{{pathToRoot}}img/chapters/beta.png"></img></center>
<p>Notice how the most likely belief for the probability of our coin is when the random variable, which represents the probability of getting a heads, is $4/6$, the fraction of heads observed. This distribution shows that we hold a non-zero belief that the probability could be something other than $4/6$. It is unlikely that the probability is 0.01 or 0.09, but reasonably likely that it could be 0.5.

<p>It works out that $\Beta(1,1) = \Uni(0,1)$. As a result the distribution of our belief about $p$ before (``prior") and after (``posterior") can both be represented using a Beta distribution. When that happens we call Beta a ``conjugate" distribution. Practically conjugate means easy update.


<h2>Beta as a Prior</h2>

<p>You can set $X \sim \Beta(a, b)$ as a prior to reflect how biased you think the coin is apriori to flipping it. This is a subjective judgment that represent $a+b- 2$ ``imaginary" trials with $a-1$ heads and $b-1$ tails. If you then observe $n + m$ real trials with $n$ heads you can update your belief. Your new belief would be, $X|(n \text{ heads in }n + m\text{ trials}) \sim \Beta(a+n, b+m)$. Using the prior $\Beta(1,1) = \Uni(0, 1)$ is the same as saying we haven't seen any ``imaginary" trials, so apriori we know nothing about the coin. This form of thinking about probabilities is representative of the ``Bayesian" field of thought where computer scientists explicitly represent probabilities as distributions (with prior beliefs). That school of thought is separate from the ``Frequentest" school which tries to calculate probabilities as single numbers evaluated by the ratio of successes to experiments.

    <script>

        $(document).ready(function() {
            console.log("HERE")
            calculate()
        })

            function calculate() {
                var alpha = Number($("#inputAlpha").val())
                var beta = Number($("#inputBeta").val())
                console.log(alpha)
                console.log(beta)
                console.log(this.jStat.beta.pdf(0.5, alpha, beta))
                
                
                $("#pdfDiv").html("")
                drawBetaPDF(pdfDiv, alpha, beta);
                $("#hidden").show()

            }

            function drawBetaPDF(parentDivId, alpha, beta) {
                var xMin = 0
                var xMax = 1
                var xStep = 0.1
                //setting up empty data array
                var data = [];
                var maxP = 0;
                var parentDiv = $(parentDivId)
                getData(alpha, beta); // popuate data 
                // line chart based on http://bl.ocks.org/mbostock/3883245
                var margin = {
                    top: 10,
                    right: 20,
                    bottom: 50,
                    left: 60
                };
                width = parentDiv.width() - margin.left - margin.right,
                height = parentDiv.height() - margin.bottom - margin.top;

                var x = d3.scale.linear()
                    .range([0, width]);

                var y = d3.scale.linear()
                    .range([height, 0]);

                var xAxis = d3.svg.axis()
                    .scale(x)
                    .orient("bottom")
                    .tickValues(range(xMin, xMax, xStep))
                    
                var yTicks = range(0, maxP * 1.2, maxP/9)
                var yAxis = d3.svg.axis()
                    .scale(y)
                    .orient("left")
                    .tickValues(yTicks);

                var line = d3.svg.line()
                    .x(function(d) {
                        return x(d.q);
                    })
                    .y(function(d) {
                        return y(d.p);
                    });

                var svg = d3.select(parentDivId).append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                var area = d3.svg.area()
                    .x(function(d) {
                        return x(d.q);
                    })
                    .y(function(d) {
                        return y(d.p);
                    });


                x.domain(d3.extent(data, function(d) {
                    return d.q;
                }));
                y.domain(d3.extent(yTicks, function(d) {
                    return d;
                }));

                


                svg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis);

                
                svg.append("g")
                    .attr("class", "y axis")
                    .call(yAxis);

                // text label for the x axis
                svg.append("text")      
                    .attr("x", width / 2 )
                    .attr("y",  height + 40 )
                    .style("text-anchor", "middle")
                    .text('x');

                // text label for the y axis
                var padding = 9 -margin.left
                svg.append("text")
                    .attr("text-anchor", "middle")  // this makes it easy to centre the text as the transform is applied to the anchor
                    .attr("transform", "translate("+ padding +","+(height/2)+")rotate(-90)")  // text is drawn off the screen top left, move down and out and rotate
                    .text("Probability Density");

                svg.append("path")
                    .datum(data)
                    .attr("class", "line")
                    .attr("d", line);


                function getData(alpha, beta) {
                    // loop to populate data array with 
                    // probabily - quantile pairs
                    maxP = 0
                    for (var x = 0; x < 1; x+= 0.01) {
                        var p = this.jStat.beta.pdf(x, alpha, beta) // calc prob of rand draw

                        el = {
                            "q": x,
                            "p": p
                        }
                        if(p > maxP) maxP = p;
                        data.push(el)
                    };
                    console.log(maxP)

                    // need to sort for plotting
                    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
                    data.sort(function(x, y) {
                        return x.q - y.q;
                    }); 
                }

            
            function range(start, end, step) {
                var range = [];
                var typeofStart = typeof start;
                var typeofEnd = typeof end;

                if (step === 0) {
                    throw TypeError("Step cannot be zero.");
                }

                if (typeofStart == "undefined" || typeofEnd == "undefined") {
                    throw TypeError("Must pass start and end arguments.");
                } else if (typeofStart != typeofEnd) {
                    throw TypeError("Start and end arguments must be of same type.");
                }

                typeof step == "undefined" && (step = 1);

                if (end < start) {
                    step = -step;
                }

                if (typeofStart == "number") {

                    while (step > 0 ? end >= start : end <= start) {
                        range.push(start);
                        start += step;
                    }

                } else if (typeofStart == "string") {

                    if (start.length != 1 || end.length != 1) {
                        throw TypeError("Only strings with one character are supported.");
                    }

                    start = start.charCodeAt(0);
                    end = end.charCodeAt(0);

                    while (step > 0 ? end >= start : end <= start) {
                        range.push(String.fromCharCode(start));
                        start += step;
                    }

                } else {
                    throw TypeError("Only string and number types are supported");
                }

                return range;

            }
        }
            

            
        </script>